# Transaction
- DBMS에서 작업의 논리적인 단위.
- 여러 작은 작업의 집합 (일반적으로 DB 레코드를 읽고 쓰는 작업을 포함함)
- Transaction은 ACID 원칙을 위배해서는 안 됨.
## ACID 원칙
- Atomicity : Transaction 의 일부만 적용되면 안 됨. 항상 Transaction 전체가 완료되어 commit 되거나, 일부만 완료된 경우에는 abort가 되어야 함.
- Consistency : Transaction의 수행으로 DB의 일관성이 깨지면 안 됨. (제약 조건에 위배되는 Transaction의 수행을 금지)
- Isolation : 여러 Transaction이 동시에 수행되더라도, 서로 간섭 받는 일 없이 독립적으로 실행되는 것 처럼 보장되어야 함.
- Durability : Transaction이 커밋에 의한 DB의 상태 변경이 디스크에 영구히 저장되고 전원 장애, 시스템 오류, 크래시 등에도 유지되어야 함

# Buffer Management
- 운영체제와 컴퓨터 구조에서 배웠던 메모리 계층 구조를 DB에서도 사용함. Disk의 내용을 RAM으로 적재해서 사용한다. 단위는 Page. 특정 Page가 참조될 때, 해당 Page가 메모리에 적재되어 있는 상태라면 메모리의 내용을 읽어가게 됨.
- DB에서 사용하는 메모리 캐싱의 경우, 다른 프로세스에 의해 Disk의 데이터가 변경되지 않았다는 가정하에 사용될 수 있다. (그렇지 않으면 예상과 다른 결과가 나오겠지.)
- 간단 용어
	- Page in : 특정 Page가 Disk에서 RAM으로 로드되는 상황
	- Dirty : 특정 Page가 RAM에 올라온 후 변경된 상태. 해당 변경 사항은 Page의 내용이 flush되며 Disk에 기록 됨.
	- Evict : Page들이 Cache되는 메모리 영역은 전체 Data set에 비해 현저히 작아, 필연적으로 Data set을 전부 적재하지 못하고 가득차는 상황이 발생할텐데, 이 상황에서 새로운 Page를 캐싱해야하는 경우 기존의 Page들 중 하나를 내보내는 것.
- Page Cache의 주 기능
	- 캐싱 된 Page의 내용을 메모리에서 유지 (Disk I/O 줄이게.)
	- Disk에 있는 Page에 대한 쓰기 작업을 메모리에 캐시된 Page에 Buffer 시켜둘 수 있음. 
	- 캐시 되지 않은 Page에 대한 참조가 일어나면, 먼저 해당 Page는 메모리에 Paged in 되고, 이로 인해 캐시 된 Page를 전달. (Page Cache에 공간이 충분한 경우에만)
	- 이미 캐시 된 Page에 대한 참조가 일어나면, 캐시되어 있는 버전을 전달.
	- Page Cache의 공간이 부족해서 새로운 Page를 적재할 수 없는 경우, 어떤 페이지를 evict 하며 해당 Page의 내용이 Disk로 Flush 됨.

### BYPASSING THE KERNEL PAGE CACHE 커널 페이지 캐시 우회하기
- 커널의 페이지를 DBMS에서 제어할 권한이 없다. `fadvise`를 통해서 어떤 페이지가 제거되면 좋겠다는 의견을 OS에 전달할 수 있지만, OS에 의해 해당 요청이 받아들여진다는 보장이 없다.이러한 `syscall` 사용을 피하기 위해 메모리 매핑을 사용하기도 하지만, 이 경우 캐싱에 대한 제어 권한을 잃게 된다.
- 그래서 많은 데이터베이스 시스템은 `0_DIRECT` 플래그를 사용한다. 이 플래그를 사용하면 I/O 시스템 콜이 커널의 페이지 캐시를 우회할 수 있게 하고, 데이터베이스 자체의 버퍼 관리를 사용할 수 있게 해준다. 단점으로는 비동기 처리가 지원되지 않고, `readhead`나 커널에 접근 패턴을 전달할 방법이 없다.

## Caching Semantics 
- 버퍼에 일어나는 모든 수정 사항은 결국에는 Disk에 써져야 할 것임. 단, Page Cache 가 참조하는 원본 파일은 다른 Process들이 수정할 수 없다고 가정하고 있으므로, Disk의 변경 사항을 메모리에 다시 적용할 걱정은 하지 않아도 된다. 즉, 메모리에 써진 변경 사항을 Disk로 써주는 단방향 동기화만 생각하면 됨.
- DB에서 사용하는 Page Cache를 OS의 Page Cache의 특별한 버전 처럼 생각하면 됨. 즉, 디스크 접근을 추상화하고 논리적 쓰기 연산과 실제 쓰기 연산을 분리하는 비슷한 목적을 가짐
- 캐싱으로 인해 DB의 알고리즘이 바뀌지 않아도 됨. 단순히 Disk에 대한 접근을 Page 캐시에 대한 접근으로 바꾸기만 하면 끝.
- Storage Engine이 Page를 참조하는 경우, 해당 Page가 캐시되어 있으면 캐시되어 있는 Page의 내용을 리턴하고, 아니면 Page 번호 혹은 논리적 주소를 실제 물리적 주소로 번역하여 해당 내용을 메모리에 캐시하고, 해당 캐시된 내용을 전달해야 함.
- 특정 페이지는 eviction을 피하기 위해 pin 될 수 있음.
- 캐시 상에서 변경된 페이지는 캐시에서 evict 될 때, Disk에 해당 페이지의 내용을 flush 해야 함.
- 5가지 목표 (서로 상충 될 수 있음.)
	- Disk 접근을 줄이기 위해 flush를 늦추기
	- eviction 속도를 빠르게 하기 위해 미리 flush 해두기
	- 최적의 순서로 Page를 evict하고 flush하기
	- 캐시 크기에 대한 메모리 제한 지키기
	- Disk에 저장하지 않아 data를 잃어버리는 것을 방지하기
## Locking Pages in Cache
- pinning 이라고 부르기도 함. 
- B-Tree의 특성 상 다른 페이지들보다 자주 참조되는 페이지가 존재하고, 이러한 페이지들을 캐시에 유지함으로써 얻는 이득 또한 크다고 할 수 있음. 그러므로 이러한 페이지들을 캐시에 고정시켜두기도.
- B-Tree의 상위 레벨의 노드들은 B-Tree 전체에서 매우 적은 비중을 차지하면서 참조는 자주되는 특성을 가지므로, 이러한 노드들을 캐시에 영구적으로 유지시킨다면, 원래는 h번의 Disk 액세스가 필요한 상황을 낮은 레벨의 Page가 캐시에 존재하지 않는 경우에만 액세스 하도록 만들 수 있다.
- Subtree에 대한 연산들 중 서로 상충되는 것이 존재할 수 있는데 (연속적인 delete 연산이나 연속적인 write 연산), 이러한 연산들을 매번 Disk에 쓰는 것이 아니라 메모리에 캐시된 곳에만 적용하고 나중에 한번에 쓰면 성능상 이득을 얻을 수 있다.
## Page Replacement
- 캐시가 가득 찬 경우, 캐시 된 Page들 중 어떤 것을 내보내어 자리를 만들어야 새로이 참조 된 Page를 캐시에 적재할 수 있다.
- 비효율적으로 내보낼 경우 (금방 다시 참조될 페이지를 내보낸 경우) 연속적인 Disk I/O 발생으로 성능이 저하될 수 있음.
- 가장 최적인 후보는 앞으로 가장 오랫동안 참조되지 않을 Page를 내보내는 것이지만, 이는 사실상 불가능한 일(미래를 예지하는 것이니까). 다만 적절한 방법을 사용한다면 eviction 횟수를 줄이는 것은 가능함.
- 단순히 캐시의 크기가 커진다고 해서 꼭 eviction 수가 줄어드는 것은 아니다.  : `belady's anormaly`
- 많은 Page Replacement 알고리즘이 존재함. 이 알고리즘들은 Latency와 I/O 연산 수를 결정하는데 큰 역할을 하므로 중요하게 고려해야 할 것.
### FIFO
- 가장 간단한 교체 전략.
- 단순히 가장 먼저 들어온 것을 가장 먼저 evict함.
- B-Tree 구조를 생각해보면 가장 많이 참조되는 가장 높은 레벨의 Page가 가장 먼저 캐싱될 것인데, 가장 먼저 evict될 후보가 되므로 그다지 좋지 않은 알고리즘 임을 알 수 있다.
### LRU
- FIFO 처럼 page-in 된 순서로 큐에 집어넣되, 다시 참조되면 해당 Page를 큐의 맨 뒤로 보내는 방식.
- 그러나 매 페이지 참조마다 link를 업데이트하고 노드를 재배치하는 것은 비용이 큼.
- 여러 번 액세스 되는 Page를 2차 `hot`큐에 집어 넣는 2Q LRU, 최근의 K 번의 액세스를 기록하는 LRU-K 등 도 존재함.
### CLOCK
- 보다 효율적인 LRU의 대체재
- 원형 큐를 사용
- 일반적인 LRU에 비해 업데이트가 훨씬 간단하고 빠름.
- 매 Page 참조마다 access bit 을 증가시키거나 counter를 증가 시킴
- Eviction이 필요할 때 동작 요령
	- hand가 원형 큐를 순회하며 아래 동작들을 수행.
	- access bit 이 1이고 현재 참조중이 아니면 access bit을 0으로 만들고 큐의 다음 Page를 검사
	- access bit이 0이면 해당 Page를 eviction 할 후보로 지정.
	- 현재 참조중인 페이지는 access bit을 1로 유지.
### LFU
- LRU가 항상 좋은 방식이라고 할 수는 없다. 특히 로드가 많은 DB의 경우에..
- 언제 Page가 참조 되었는지보다, 얼마나 많이 참조 되었는지를 가지고 eviction을 결정하는 방식.
- TinyLFU
	- frequency histogram을 통해 캐시 접근 기록을 관리.
	- Admission, Probation, Protected 3가지 단계로 Page를 관리 함.
	- Admission : 새로 참조된 Page가 잠시 머무르는 곳. LRU 기반
	- Probation : 곧 evict 될 Page들의 모음
	- Protected : 더 오래 큐에 머무를 Page들의 모음
	- 바로 캐시에 넣고 빼기보다 최소한 몇 번 이상 참조된 것들을 캐시에 유지하는 방식. eviction은 Probation에서만 일어난다!